    # video_save = cv2.VideoWriter("C:\\Users\\SWC\Desktop\\videos\\" + mouse_date + str(i+1) + ".mp4", cv2.VideoWriter_fourcc(*"XVID"), fps, (1024, 1024), True)
    # video_save.release()


from distutils.core import setup

setup(name='opto_analysis', version='1.0.0', packages=['opto_analysis'])


            # shading_colors = [np.array(x) for x in [[254, 254, 254], [254, 253.5, 252.6], [254, 250, 240], [254, 250, 200], [200, 250, 254]]]
            # i = np.where( (self.speed - speed_thresholds)>0 )[0][-1] # index within the speed thresholds
            # shading_color_based_on_speed = ((speed_thresholds[i+1] - self.speed) * shading_colors[i] + (self.speed - speed_thresholds[i]) * shading_colors[i+1]) / (speed_thresholds[i+1] - speed_thresholds[i]) # somewhere between the darker and brighter color depending on its speed relative to the threshold speeds
            # self.shading_color_light = 1 - (1 - shading_color_based_on_speed / [255, 255, 255]) / (np.mean(1 - shading_color_based_on_speed / [255, 255, 255]) / .08)
            # self.shading_color_dark = (1 - (1 - shading_color_based_on_speed / [255, 255, 255]) / (np.mean(1 - shading_color_based_on_speed / [255, 255, 255]) / .38))**2


    def determine_trial_eligibility(self, stim_type):
        self.ineligible = stim_type=='audio' and \
                          (self.current_num_prev_escapes >= self.settings.max_escapes_per_mouse or \
                           self.current_trial_time_to_shelter > self.settings.max_time_to_reach_shelter)

    def extract_trajectory(self, stim_type, onset_frames):
        pass

                    distance_from_trial_start = \
                  ((self.tracking_data['avg_loc'][trial_start_idx:,0] - self.tracking_data['avg_loc'][trial_start_idx,0])**2 +\
                   (self.tracking_data['avg_loc'][trial_start_idx:,1] - self.tracking_data['avg_loc'][trial_start_idx,1])**2)**.5

                    np.where(distance_from_trial_start>500)[0][0]



    RT = get_escape_initiation_idx(self, trial_start_idx)
    x_start, y_start, x_goal, y_goal, x_center, y_center, _, _, _, _, _ = get_various_x_and_y_locations(self, x, y, RT)
    # _, x_homing_vector = distance_to_line(x_center, y_center, x_start, y_start, x_goal, y_goal)
    # leftside = x_center < x_homing_vector


        def homing_extraction_already_done(self):
        if isinstance(self.session.spontaneous, None): return False
        same_settings_as_saved_homings = \
            [self.settings.__dict__[setting]==self.session.spontaneous.__dict__[setting] for setting in \
                ['speed', 'smooth duration', 'close_to_shetler_angle', 'minimum_shelter_distance', 'angle_speed_threshold']]
        if np.array(same_settings_as_saved_homings).all(): return True
        return False


                face_shelter_or_edge           = self.homing_angle          < self.settings.heading_dir_threshold_angle
                        face_shelter_at_all            = self.shelter_angle         < 90


    # edge_loc_1 = (self.session.video.width/2 - 250, self.session.video.height/2)
    # edge_loc_2 = (self.session.video.width/2 + 250, self.session.video.height/2)
    # distance_from_edge_loc_1 = min(((x - edge_loc_1[0])**2 + (y - edge_loc_1[1])**2)**.5)
    # distance_from_edge_loc_2 = min(((x - edge_loc_2[0])**2 + (y - edge_loc_2[1])**2)**.5)
    # min_distance_from_edge   = min(distance_from_edge_loc_1, distance_from_edge_loc_2) 
    # if min_distance_from_edge < 50: return 1
    # if min_distance_from_edge > 50: return 0                        